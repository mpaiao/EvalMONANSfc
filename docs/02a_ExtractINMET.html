<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Marcos Longo" />

<meta name="date" content="2026-02-26" />

<title>Pre-process INMET data</title>

<script src="site_libs/header-attrs-2.30/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/darkly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>






<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">MONAN Evaluator (Surface)</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="EvalMONAN_SfcStation.html">Station evaluator</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Pre-process INMET data</h1>
<h4 class="author">Marcos Longo</h4>
<h4 class="date">2026-02-26</h4>

</div>


<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}
</style>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>This R Markdown helps pre-process automatic weather station data from
Brazil’s National Institute of Meteorology (INMET). Data are available
for download by year at <a href="https://bdmep.inmet.gov.br">INMET’s
meteorological data base portal</a>. This script has been tested with
data downloaded in bulk from the first link available (web site in
Portuguese).</p>
<p>This script requires some functions available in sub-directory
<code>RUtils</code>, which is available in the repository.</p>
</div>
<div id="reset-session" class="section level1">
<h1>Reset session</h1>
<p>Use this chunk to fully reset R.</p>
<pre class="r"><code># Unload all packages except for the R default ones
plist = names(sessionInfo()$otherPkgs)
if (length(plist) &gt; 0){
   dummy = sapply(X=paste0(&quot;package:&quot;,plist),FUN=detach,character.only=TRUE,unload=TRUE)
}#end if (length(plist) &gt; 0)


# Remove all variables
rm(list=ls())

# Reset warnings
options(warn=0)

# Close all plots
invisible(graphics.off())

# Clean up
invisible(gc())</code></pre>
</div>
<div id="user-configuration" class="section level1">
<h1>User configuration</h1>
<p>In this part, we set a few useful global paths, files, and
variables.</p>
<p>First, we set some global paths and files:</p>
<ul>
<li><strong>home_path</strong>. Typically the user’s home path. Useful
for building other paths. <code>path.expand("~")</code> typically works
for all users.</li>
<li><strong>main_path</strong>. Typically the main directory where all
MONAN’s surface evaluation scripts are located.</li>
<li><strong>observed_path</strong>. The main directory containing text
files with all observations. Typically the main path that will host both
the raw and the consolidated INMET files.</li>
<li><strong>input_path</strong>. The location where the original INMET
files are located. Following INMET’s bulk download, files should be
stored in one sub-directory for each year.</li>
<li><strong>output_path</strong>. The main output path for the data. A
sub-directory for this site will be created.</li>
<li><strong>util_path</strong>. The path with the additional utility
scripts (the full path of <code>RUtils</code>).</li>
</ul>
<pre class="r"><code>home_path     = path.expand(&quot;~&quot;)
main_path     = file.path(home_path,&quot;Documents&quot;,&quot;LocalData&quot;,&quot;EvalMONANSfc&quot;)
observed_path = file.path(main_path,&quot;Observations&quot;,&quot;INMET&quot;)
util_path     = file.path(main_path, &quot;RUtils&quot;)
input_path    = file.path(observed_path,&quot;Original&quot;)
output_path   = file.path(observed_path,&quot;Consolidated&quot;)</code></pre>
<p>We then set the first (<code>whena</code>) and last
(<code>whenz</code>) times to be processed. Provide both in format
<code>"YYYY-MM-DD"</code>.</p>
<pre class="r"><code>whena = &quot;2025-11-01&quot; # First date (&quot;A&quot;)
whenz = &quot;2026-02-28&quot; # Last date (&quot;Z&quot;)</code></pre>
<p>Define some lower and upper bounds for meteorological variables.
These should be vectors with length 2, representing the lower and upper
bound of what we consider physically possible and that will not give
trouble when deriving the other quantities. Please refrain from making
the range too strict and narrow, to avoid unintentionally discarding
data. Note that the range should be defined in the same units as
MONAN:</p>
<ul>
<li><strong>mslp_bnds</strong>. Bounds for mean sea level pressure, in
<span class="math inline">\(\mathrm{Pa}\)</span>.</li>
<li><strong>acswdnb_bnds</strong>. Bounds for accumulated downward
shortwave irradiance, in <span
class="math inline">\(\mathrm{J}\,\mathrm{m}^{-2}\)</span>.</li>
<li><strong>t2m_bnds</strong>. Bounds for 2-m temperature, in <span
class="math inline">\(\mathrm{K}\)</span>.</li>
<li><strong>td2m_bnds</strong>. Bounds for 2-m dew point temperature, in
<span class="math inline">\(\mathrm{K}\)</span>.</li>
<li><strong>ws10_bnds</strong>. Bounds for 10-m wind speed, in <span
class="math inline">\(\mathrm{m}\,\mathrm{s}^{-1}\)</span>.</li>
<li><strong>wd10_bnds</strong>. Bounds for 10-m wind direction, in <span
class="math inline">\(^{\circ}\)</span>.</li>
</ul>
<pre class="r"><code>mslp_bnds    = c(  85000.,  110000.) # Pa
acswdnb_bnds = c(      0., 4932000.) # J/m2
t2m_bnds     = c(    180.,     335.) # K
td2m_bnds    = c(    180.,     335.) # K
ws10_bnds    = c(      0.,     200.) # m/s
wd10_bnds    = c(      0.,     360.) # deg</code></pre>
</div>
<div id="main-script" class="section level1">
<h1>Main script</h1>
<p><strong>Note:</strong> Changes beyond this point are only needed if
you are developing the notebook.</p>
<div id="initial-settings" class="section level2">
<h2>Initial settings</h2>
<p>First, we load some useful packages.</p>
<pre class="r"><code>cat(&quot; + Load required packages.\n&quot;)
# Load all required packages
isfine = 
   c( data.table   = require(data.table)
    , extraDistr   = require(extraDistr)
    , extrafont    = require(extrafont)
    , ggstar       = require(ggstar)
    , grDevices    = require(grDevices)
    , maps         = require(maps)
    , MASS         = require(MASS)
    , patchwork    = require(patchwork)
    , RColorBrewer = require(RColorBrewer)
    , scales       = require(scales)
    , sf           = require(sf)
    , sn           = require(sn)
    , tidyverse    = require(tidyverse)
    , viridis      = require(viridis)
    )#end c

# Check that all packages were successfully loaded.
if (any(! isfine)){
   cat(&quot;---~---\n&quot;)
   cat(&quot;   FATAL ERROR!!! \n&quot;)
   cat(&quot;---~---\n&quot;)
   cat(&quot; The following packages are needed but could not be loaded:\n&quot;)
   cat(&quot; - &quot;,paste(names(isfine)[! isfine],collapse=&quot;, &quot;),&quot;.\n&quot;,sep=&quot;&quot;)
   cat(&quot;---~---\n&quot;)
   stop(&quot; Missing required packages&quot;)      
}#end if (any(! isfine))
</code></pre>
<p>We then load all R scripts in the utilities directory.</p>
<pre class="r"><code>cat(&quot; + Load additional R scripts.\n&quot;)
# List all R scripts, but exclude those likely to be backups.
script_list = sort(list.files(path=util_path,pattern=&quot;\\.[Rr]$&quot;))
backup_list = sort(list.files(path=util_path,pattern=&quot;^[~]&quot;))
script_list = script_list[! script_list %in% backup_list]

# Load all files and make sure they are alright.
warn_orig = getOption(&quot;warn&quot;)
options(warn=2)
for ( script_base in script_list){
   script_file = file.path(util_path,script_base)
   success = try(source(script_file,chdir=TRUE),silent=TRUE)
   if (&quot;try-error&quot; %in% is(success)){
      options(warn=warn_orig)
      cat(&quot;---~---\n&quot;)
      cat(&quot;   FATAL ERROR!!! \n&quot;)
      cat(&quot;---~---\n&quot;)
      cat(&quot;   Script &quot;,script_base,&quot; has bugs! Check the errors/warnings:\n&quot;,sep=&quot;&quot;)
      cat(&quot;---~---\n&quot;)
      source(script_file,chdir=TRUE)
      stop(&quot; Source code problem.&quot;)      
   }#end if (&quot;try-error&quot; %in% is(success))
}#end for ( script_file in script_list)
options(warn=warn_orig)</code></pre>
<p>We create the output path in case it is not there.</p>
<pre class="r"><code>cat0(&quot; + Make sure the output path exists.&quot;)
dummy = dir.create(output_path,recursive=TRUE,showWarnings=FALSE)</code></pre>
<p>We then set times for looping through times.</p>
<pre class="r"><code>cat0(&quot; + Set time bounds and time steps.&quot;)
whena    = as.integer(strsplit(x=whena,split=&quot;-&quot;)[[1L]])
whenz    = as.integer(strsplit(x=whenz,split=&quot;-&quot;)[[1L]])
whena    = lubridate::make_datetime( year = whena[1L], month = whena[2L], day = whena[3L]
                                   , hour = 0L       , min   = 0L       , sec = 0L
                                   , tz   = &quot;UTC&quot;    )
whenz    = lubridate::make_datetime( year = whenz[1L], month = whenz[2L], day = whenz[3L]
                                   , hour = 23L      , min   = 59L      , sec = 59L
                                   , tz   = &quot;UTC&quot;    )
yeara    = lubridate::year(whena)
yearz    = lubridate::year(whenz)
when_seq = seq(from=whena,to=whenz,by=&quot;1 hour&quot;)</code></pre>
<p>We then find the expected range of water vapour partial pressure,
which in turn will be used for finding a range for surface pressure. The
range is defined by the lowest temperature bound and 0.1% relative
humidity, and the highest temperature bound and 100% relative
humidity.</p>
<p>The bounds for surface pressure must be found later, because they
depend on the elevation of each site.</p>
<pre class="r"><code>pvap2m_bnds = c( 0.001 * t2m_to_pvsat2m(t2m=t2m_bnds[1L]), t2m_to_pvsat2m(t2m=t2m_bnds[2L]) )</code></pre>
<p>Finally, we set up an information tibble object that will summarise
all stations available.</p>
<pre class="r"><code># Initialise information table.
inmet_info = tibble( ident     = character(0L)
                   , lon       = numeric  (0L)
                   , lat       = numeric  (0L)
                   , alt       = numeric  (0L)
                   , site      = character(0L)
                   , state     = character(0L)
                   , last_year = integer  (0L)
                   )#end tibble</code></pre>
</div>
</div>
<div id="main-data-processing." class="section level1">
<h1>Main data processing.</h1>
<p>In this loop, we perform the following tasks: 1. Retrieve original
data as it looks like from INMET. 2. Obtain the meta-data and place them
in the summary tibble object. 3. Apply a very basic QA/QC (values within
physically meaningful ranges) 4. Find a few derived thermodynamic and
meteorological variables. Most derived quantities use functions defined
in script <code>RUtils/thermo_phys_library.r</code>. 5. Trim data to the
period of interest and append the data to a global structure to a tibble
containing all data.</p>
<pre class="r"><code># Loop through years.
inmet_data = NULL
for (year in seq(from=yeara,to=yearz,by=1L)){
   # List all files.
   cat0(&quot; + Process data for &quot;,year,&quot;.&quot;)
   year_path       = file.path (input_path,year)
   inmet_file_list = list.files( path        = year_path
                               , pattern     = &quot;\\.csv$&quot;
                               , ignore.case = TRUE
                               , full.names  = TRUE
                               )#end list.files
   inmet_file_list = sort(inmet_file_list)


   # Loop through all files.
   for (inmet_file in inmet_file_list){
      # Open file and read the header
      inmet_header = suppressMessages( read_csv2( file           = inmet_file
                                                , n_max          = 8L
                                                , col_names      = FALSE
                                                , show_col_types = FALSE
                                                , progress       = FALSE
                                                )#end read_csv2
                                     )#end suppressMessages
      inmet_state  = str_to_upper(inmet_header$X2[2L])
      inmet_site   = str_to_title(inmet_header$X2[3L])
      inmet_ident  = str_to_upper(inmet_header$X2[4L])
      inmet_lat    = as.numeric(gsub(pattern=&quot;\\,&quot;,replacement=&quot;.&quot;,x=inmet_header$X2[5L]))
      inmet_lon    = as.numeric(gsub(pattern=&quot;\\,&quot;,replacement=&quot;.&quot;,x=inmet_header$X2[6L]))
      inmet_alt    = as.numeric(gsub(pattern=&quot;\\,&quot;,replacement=&quot;.&quot;,x=inmet_header$X2[7L]))
      cat0(&quot;   - Site &quot;,inmet_site,&quot; &quot;,inmet_state,&quot; (&quot;,inmet_ident,&quot;).&quot;)

      # Append site if it is not there already.
      if (inmet_ident %in% inmet_info$ident){
         ih = match(inmet_ident,inmet_info$ident)
         if (year == inmet_info$last_year[ih]){
            cat0(&quot;&quot;)
            cat0(&quot;---~---&quot;)
            cat0(&quot;   FATAL ERROR!!!&quot;)
            cat0(&quot;---~---&quot;)
            cat0(&quot;   + Site &quot;,inmet_site,&quot; &quot;,inmet_state,&quot; (&quot;,inmet_ident,&quot;).&quot;)
            cat0(&quot;   + This site is duplicated for year &quot;,year,&quot;!!&quot;)
            cat0(&quot;---~---&quot;)
            stop(&quot; Sites should have a single file per year.&quot;)
         }else{
            cat0(&quot;     ~ Site is already in the look-up table. Update last year&quot;)
            inmet_info$last_year[ih] = year
         }#end if (year == inmet_info$last_year[ih])
      }else{
         cat0(&quot;     ~ Add site to the look-up table.&quot;)
         this_info  = tibble( ident     = inmet_ident
                            , lon       = inmet_lon
                            , lat       = inmet_lat
                            , alt       = inmet_alt
                            , site      = inmet_site
                            , state     = inmet_state
                            , last_year = year
                            )#end tibble
         inmet_info = rbind(inmet_info,this_info)
      }#end if (! inmet_ident %in% inmet_info$ident)

      # Load data.
      this_datum = suppressMessages( read_csv2( file           = inmet_file
                                              , skip           = 9L
                                              , col_names      = FALSE
                                              , col_types      = &quot;ccnnnnnnnnnnnnnnnnnc&quot;
                                              , show_col_types = FALSE
                                              )#end read_csv2
                                   )#end suppressMessages
      names(this_datum) = c( &quot;date_str&quot;, &quot;time_str&quot;,&quot;rain&quot;,&quot;surface_pressure&quot;
                           , &quot;min_surface_pressure&quot;, &quot;max_surface_pressure&quot;
                           , &quot;acswdnb&quot;,&quot;t2m&quot;,&quot;td2m&quot;,&quot;max_t2m&quot;,&quot;min_t2m&quot;,&quot;max_td2m&quot;
                           , &quot;min_td2m&quot;,&quot;max_rh2m&quot;,&quot;min_rh2m&quot;,&quot;rh2m&quot;,&quot;wd10&quot;,&quot;max_ws10&quot;
                           , &quot;ws10&quot;,&quot;dummy&quot;)

      # Standardise time
      this_datum = this_datum %&gt;%
         mutate( year  = as.integer( substr( x = date_str, start = 1L, stop =  4L ) )
               , month = as.integer( substr( x = date_str, start = 6L, stop =  7L ) )
               , day   = as.integer( substr( x = date_str, start = 9L, stop = 10L ) )
               , hour  = as.integer( substr( x = time_str, start = 1L, stop =  2L ) )
               , min   = as.integer( substr( x = time_str, start = 3L, stop =  4L ) )
               , when  = make_datetime( year = year, month = month, day = day
                                      , hour = hour, min   = min  , sec = 0L
                                      , tz   = &quot;UTC&quot;)
               )#end mutate

      # Add station information
      this_datum = this_datum %&gt;%
         mutate( ident   = inmet_ident
               , site    = inmet_site
               , lon     = inmet_lon
               , lat     = inmet_lat
               , ter     = inmet_alt
               , state   = inmet_state
               )#end mutate

      # Make sure the units match those used in MONAN.
      this_datum = this_datum %&gt;%
         mutate( surface_pressure = surface_pressure * hPa_to_Pa
               , acswdnb          = acswdnb * kJ_to_J
               , t2m              = t2m  + t00
               , td2m             = td2m + t00
               )#end mutate

      #    Find the range for surface pressure. The low-pressure bound is found with the lowest bound
      # for all three dependent variables (mean surface-level pressure, temperature, vapour pressure).
      # Likewise, the high-pressure bound uses the upper bound of these variables. This is because
      # theas they are all positively correlated with pressure. 
      surface_pressure_bnds = find_sfc_pressure(mslp=mslp_bnds,t2m=t2m_bnds,pvap2m=pvap2m_bnds,ter=inmet_alt)

      
      # Discard data outside reasonable range.
      this_datum = this_datum %&gt;%
         mutate( surface_pressure = check_bounds( x = surface_pressure, xBounds = surface_pressure_bnds)
               , acswdnb          = check_bounds( x = acswdnb         , xBounds = acswdnb_bnds         )
               , t2m              = check_bounds( x = t2m             , xBounds = t2m_bnds             )
               , td2m             = check_bounds( x = td2m            , xBounds = td2m_bnds            )
               , ws10             = check_bounds( x = ws10            , xBounds = ws10_bnds            )
               , wd10             = check_bounds( x = wd10            , xBounds = wd10_bnds            )
               )#end mutate
      
      # Find derived quantities
      this_datum = this_datum %&gt;%
         mutate( pvap2m = t2m_to_pvsat2m(t2m=td2m)
               , q2     = find_q2m(surface_pressure,t2m,pvap2m)
               , u10    = find_u10(ws10,wd10)
               , v10    = find_v10(ws10,wd10)
               , tv2m   = find_tv2m(surface_pressure,t2m,pvap2m)
               , mslp   = find_mslp(surface_pressure, t2m, pvap2m, ter)
               )#end mutate

      # Select variable to carry out.
      cat0(&quot;     ~ Trim data to variables and period of interest.&quot;)
      this_datum = this_datum                              %&gt;%
         select(when,ident,site,lon,lat,ter
               ,surface_pressure,mslp,acswdnb,u10,v10
               ,q2,t2m,pvap2m,td2m,rain                  ) %&gt;%
         filter( ( when &gt;= whena ) &amp; ( when &lt;= whenz ) )

      # Append data to the global data set.
      inmet_data = rbind(inmet_data,this_datum)
   }#end for (inmet_file in inmet_file_list)
}#end for (yearn in seq(from=yeara,to=yearz,by=1L))</code></pre>
<p>Sort all data by time and station.</p>
<pre class="r"><code>cat0(&quot; + Sort data by time and station.&quot;)
inmet_info = inmet_info %&gt;%
   arrange(ident)
inmet_data = inmet_data %&gt;%
   arrange(ident,when)</code></pre>
</div>
<div id="write-site-specific-csv-files" class="section level1">
<h1>Write site-specific csv files</h1>
<p>We make some final adjustments to the data sets, such as including
all times within the period of interest, and write standardised
site-specific csv files with all files. We also count the number of
valid measurements for each site and variable, and add a few pieces of
information to the site list summary.</p>
<pre class="r"><code># Add variables that will tally the number of valid observations.
cat0(&quot; + Append observation count variables to the summary table.&quot;)
inmet_info = inmet_info                                              %&gt;%
   select(ident,lon,lat,alt,site,state)                              %&gt;%
   mutate( n_surface_pressure = NA_integer_
         , n_mslp             = NA_integer_
         , n_acswdnb          = NA_integer_
         , n_u10              = NA_integer_
         , n_v10              = NA_integer_
         , n_q2               = NA_integer_
         , n_t2m              = NA_integer_
         , n_pvap2m           = NA_integer_
         , n_td2m             = NA_integer_
         , n_rain             = NA_integer_ )                        %&gt;%
   select(ident,lon,lat,alt,site,state,n_surface_pressure
         ,n_mslp,n_acswdnb,n_u10,n_v10,n_q2,n_t2m,n_pvap2m,n_td2m
         ,n_rain                                                  )


# Extract data for each site and produce site-specific csv files with no time gaps.
cat0(&quot; + Write csv files for each individual site.&quot;)
n_inmet    = nrow(inmet_info)
for (i in sequence(n_inmet)){
   # Pick information.
   i_ident    = inmet_info$ident [i]
   i_site     = inmet_info$site  [i]
   i_lon      = inmet_info$lon   [i]
   i_lat      = inmet_info$lat   [i]
   i_alt      = inmet_info$alt   [i]
   i_state    = inmet_info$state [i]
   i_label    = gsub(pattern=&quot; &quot;,replacement=&quot;&quot;,x=i_site)

   # Define output file.
   inmet_base  = paste0(&quot;inmet_&quot;,i_ident,&quot;_&quot;,i_label,&quot;.csv&quot;)
   inmet_file  = file.path(output_path,inmet_base)
   cat0(&quot;   - Site: &quot;,i_site,&quot; ( &quot;,i_ident,&quot;).&quot;)

   # Initialise METAR file containing all times.
   inmet_output = tibble( when             = when_seq
                        , ident            = i_ident
                        , site             = i_site
                        , lon              = i_lon
                        , lat              = i_lat
                        , ter              = i_alt
                        , state            = i_state
                        , surface_pressure = NA_real_
                        , mslp             = NA_real_
                        , acswdnb          = NA_real_
                        , u10              = NA_real_
                        , v10              = NA_real_
                        , q2               = NA_real_
                        , t2m              = NA_real_
                        , pvap2m           = NA_real_
                        , td2m             = NA_real_
                        , rain             = NA_real_
                        )#end tibble

   # Subset global tibble and write the site-specific data.
   this_inmet = inmet_data %&gt;%
      filter( ident %in% i_ident )

   # Find the number of valid data points.
   cat0(&quot;     &gt; Tally the number of valid observations.&quot;)
   inmet_info$n_surface_pressure[i] = sum(is.finite(this_inmet$surface_pressure))
   inmet_info$n_mslp            [i] = sum(is.finite(this_inmet$mslp            ))
   inmet_info$n_acswdnb         [i] = sum(is.finite(this_inmet$acswdnb         ))
   inmet_info$n_u10             [i] = sum(is.finite(this_inmet$u10             ))
   inmet_info$n_v10             [i] = sum(is.finite(this_inmet$v10             ))
   inmet_info$n_q2              [i] = sum(is.finite(this_inmet$q2              ))
   inmet_info$n_t2m             [i] = sum(is.finite(this_inmet$t2m             ))
   inmet_info$n_pvap2m          [i] = sum(is.finite(this_inmet$pvap2m          ))
   inmet_info$n_td2m            [i] = sum(is.finite(this_inmet$td2m            ))
   inmet_info$n_rain            [i] = sum(is.finite(this_inmet$rain            ))

   # Find available times for this site.
   ii = match(this_inmet$when,inmet_output$when)
   inmet_output$surface_pressure[ii] = this_inmet$surface_pressure
   inmet_output$mslp            [ii] = this_inmet$mslp
   inmet_output$acswdnb         [ii] = this_inmet$acswdnb
   inmet_output$u10             [ii] = this_inmet$u10
   inmet_output$v10             [ii] = this_inmet$v10
   inmet_output$q2              [ii] = this_inmet$q2
   inmet_output$t2m             [ii] = this_inmet$t2m
   inmet_output$pvap2m          [ii] = this_inmet$pvap2m
   inmet_output$td2m            [ii] = this_inmet$td2m
   inmet_output$rain            [ii] = this_inmet$rain

   # Write csv file
   dummy = write_csv( x         = inmet_output
                    , file      = inmet_file
                    , na        = &quot;&quot;
                    , append    = FALSE
                    , col_names = TRUE
                    )#end write_csv
}#end for (m in sequence(n_metar))</code></pre>
</div>
<div id="summary-table-output" class="section level1">
<h1>Summary table output</h1>
<p>Lastly, we write the summary to a csv file. This will be useful for
extracting model results for each of the sites.</p>
<pre class="r"><code>info_base = &quot;INMET_SiteInfo.csv&quot;
info_csv  = file.path(main_path,info_base)
cat0(&quot; + Write site table summary to &quot;,info_base,&quot;.&quot;)
dummy     = write_csv( x         = inmet_info
                     , file      = info_csv
                     , na        = &quot;&quot;
                     , append    = FALSE
                     , col_names = TRUE
                     )</code></pre>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
